{"meta":{"title":"Mirac1e's blogs","subtitle":"记录学到的点点滴滴","description":"No pains，no gains","author":"Miracle","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-02-26T15:18:35.000Z","updated":"2020-02-26T16:30:00.387Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-26T15:19:56.000Z","updated":"2020-02-26T16:29:23.861Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础知识复习整理（四）","slug":"Java基础知识复习整理（四）","date":"2020-03-02T12:04:34.000Z","updated":"2020-03-02T13:08:45.565Z","comments":true,"path":"2020/03/02/Java基础知识复习整理（四）/","link":"","permalink":"http://yoursite.com/2020/03/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"接口接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。 接口中所有的方法都自动地属于public，因此在接口中声明方法时不必提供关键字public。 123456//Java中的Comparable接口//该接口只有一个方法，有些接口可能包含多个方法，还可以定义常量//接口不能有实例域！原则上也不能有静态方法，但是Java SE 8中允许在接口中增加静态方法public interface Comparable&lt;T&gt;&#123; int CompareTo(T other);&#125;","text":"接口接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。 接口中所有的方法都自动地属于public，因此在接口中声明方法时不必提供关键字public。 123456//Java中的Comparable接口//该接口只有一个方法，有些接口可能包含多个方法，还可以定义常量//接口不能有实例域！原则上也不能有静态方法，但是Java SE 8中允许在接口中增加静态方法public interface Comparable&lt;T&gt;&#123; int CompareTo(T other);&#125; 为了让类实现一个接口， 通常需要下面两个步骤： 1 ) 将类声明为实现给定的接口。 2 ) 对接口中的所有方法进行定义。 接口的特性接口不是类，不能使用new运算符实例化一个接口。但是可以声明一个接口的变量指向实现接口的类对象。 1234567public interface person&#123;&#125;public class man implements person&#123;&#125;person p = new man();//也可以使用instanceof检查一个对象是否实现了某个接口man m = new man();if(m instanceof person)&#123;. . .&#125; 接口也可以扩展，允许存在多条从具有较高通用性的接口到较高专用性的接口的链。 12345678public interface A&#123; int methodA();&#125;public interface B extends A()&#123; int methodB(); //可以包含常量，这些常量被自动设置为：public static final int NUM = 1;&#125; 有的接口只定义了常量而没有方法，任何实现了该接口的类都能自动继承这些常量。 尽管每个类只能有一个超类，但却可以实现多个接口。（这就是为什么有了抽象类还要引入接口的原因） 默认方法可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。 123public interface Comparable&lt;T&gt;&#123; default int compareTo(T other) &#123; return 0; &#125; &#125; 如果先在一个接口中将一个方法定义为默认方法， 然后又在超类或另一个接口中定义了同样的方法，java相应的规则如下 1 ) 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。 2 ) 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法， 必须手动重写这个方法来解决冲突。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础知识复习整理（三）","slug":"Java基础知识复习整理（三）","date":"2020-03-01T12:02:09.700Z","updated":"2020-03-02T12:19:17.108Z","comments":true,"path":"2020/03/01/Java基础知识复习整理（三）/","link":"","permalink":"http://yoursite.com/2020/03/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"继承继承是面向对象的重要概念，在Java中不支持多继承。 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。","text":"继承继承是面向对象的重要概念，在Java中不支持多继承。 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 覆盖方法子类一般只是继承了父类的特征，而往往我们定义的子类都有自己新的特征。所以有时候需要修改父类的某些方法，这个过程叫做重写(override)。但是子类的方法并不能访问父类的私有域，尽管子类从父类中继承了这个域，也只有父类的方法才能访问私有部分。所以子类要想访问私有域，就需要私有公有的接口。但是子类也有这个方法，为了区分，需要使用super关键字。 123public int getAge()&#123; return super.getAge();&#125; 同样因为这个原因，子类的构造器再给私有域赋值时，可以使用super关键字调用父类的构造方法，但是不需要加上方法名。 123public Student(String name,int age)&#123; super(name,age);&#125; 多态多态是Java的重要特征之一。 继承关系是”is-a”关系，表明子类的每个对象也是父类的对象，程序中出现超类对象的任何地方都可以用子类对象置换。 方法调用多态经常体现在方法调用的时候。最简单的，如重载，方法有着相同的方法名，但是参数列表不同，这时候编译器会根据参数列表去匹配决定调用哪一个方法，这个过程是静态的，叫做静态绑定。 还有一种更加复杂的情况是父类引用指向子类对象。看如下代码： 12345678910111213141516171819202122232425262728293031public class TestDemo &#123; public static void main(String[] args) &#123; A ab = new B(); A a = new A(); D d = new D(); ab.Show(a); ab.Show(d); &#125;&#125;class A&#123; public void Show(A a)&#123; System.out.println(\"A and A\"); &#125; public void Show(C c)&#123; System.out.println(\"A and C\"); &#125;&#125;class B extends A&#123; public void Show(A a)&#123; System.out.println(\"B and A\"); &#125;&#125;class C extends B&#123;&#125;class D extends C&#123;&#125;/*Output: B and A A and C*/ 会产生这种输出的原因是： 对象ab是A的引用指向B的对象，在编译时，Java编译器会根据ab的引用A去在类A的方法中匹配需要调用的方法，如果没有匹配到，则会编译会报错。运行时，由于ab是B的对象，所以虚拟机会看在B中是否对该方法进行了重写，如果重写了则调用B的方法，如果没有就会调用A的方法，这个过程叫做动态绑定。所以说： 重写是动态的，重载是静态的。 产生第二行输出是因为编译器在选择需要调用的方法时没有匹配到对应的方法，于是编译器会将对象d向上转型，这时候便和Show(C c)这个方法匹配上了。 总结来说，就是绑定需要调用的方法时： ①如果是静态方法，只看左边，即只看引用的类型，因为静态方法是属于类的。 ②如果是非静态方法，那么编译时看左边，运行时看右边。 阻止继承final类和方法如果希望某个类不能被继承，那么可以使用final关键字进行修饰，那么其他类就不能继承这个类。 123public final class A&#123; . . .&#125; 同样的如果希望类中的某个类不能被重写也可以声明成final，那么他的子类便不能对这个方法进行重写 123public final String DoSomething()&#123; . . .&#125; Object类object类是所有类的超类，Java中每个类都是由他扩展而来。 equals方法object类中定义了equals方法检测两个对象是否相等。但是在object类中该方法判断的是两个对象是否有相同的引用，即和==一样。在String类中，重写了该equals方法，判断两个字符串类容是否相同，这就是为什么String类中equals方法和==有区别的原因。 通常情况下，比较两个对象是否相等我们一般要判断他们的域是否相等，所以可以按如下代码重写equals方法。 12345678910111213141516171819202122public class Student&#123; String name; int age; public boolean equals(Object otherObject) &#123; // a quick test to see if the objects are identical if (this == otherObject) return true; // must return false if the explicit parameter is null if (otherObject == null) return false; // if the classes don't match, they can't be equal if (getClass() != otherObject.getClass()) return false; // now we know otherObject is a non-null Student Student other = (Student) otherObject; // test whether the fields have identical values return name.equals(otherObject.name) &amp;&amp; age = otherObject.age; &#125;&#125;/** getClass方法返回的不是引用的对象名，而是具体对象名。如：* A ab = new B();* ab.getClass();* 返回的是Class B;*/ hashCode方法hash code是由对象导出的一个整型值。因为这个方法是Object类中的方法，所以每一个对象都有一个默认的散列码，如果一个类没有重写hashCode方法，那么默认的散列码为对象的储存地址。 toString方法返回表示对象值的字符串 泛型数组列表Java提供了ArrayList类能够在运行时自动调节数组容量。可以按如下方式声明 1ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); 尖括号中定义的是存储的数据类型(不允许使用基本数据类型)，Java SE7中，可以省去右边的尖括号。 该类的常用API有： 123456boolean add(E obj) //在数组尾端添加一个元素。int size() //返回数组的元素个数void set(int index,E obj) //设置指定位置的元素值E get(int index) //获得指定位置的元素值void add(int index,E obj) //在指定位置向后移动元素以便插入新元素E remove(int index) //删除一个元素，并将后面的元素向前移动 对象包装器与自动装箱前面提到ArrayList中不允许是基本数据类型，所以需要将int这样的基本类型转换成对象。所有的基本类型都有一个与之对应的类，为Integer，Long，Short，Byte，Float，Double，Character，Void，Boolean。前六个类都派生于公共的超类Number。对象包装器是不可变的，一旦构造就不能修改其中的值。 当往一个存储Integer对象的list中存放值时，如list.add(3),将自动变为list.add(Integer.valueOf(3))。这个变换叫做自动装箱。相反Integer赋给一个int时，将会自动的拆箱。 反射Java反射机制是指运行状态中。对于任何一个类，都能知道的这个类的所有属性和方法。对于任何一个对象，都能调用它的任意方法和属性。这种动态获取程序信息以及动态调用对象的功能称为Java的反射机制。 Class对象 通过这幅图我们可以理解什么是Class对象。在程序运行期间，Java运行时系统始终为所有对象维护一个被称作运行时的类型标识，这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。可以通过一个专门的Java类访问这些信息，保存这些信息的类叫做Class。Object类中的getClass方法将会返回一个Class类型的实例。 Class类的实例表示正在运行的Java应用程序中的类和接口。也就是JVM中有N多的实例每个类都有该Class对象（包括基本数据类型）。一个类的N多实例共享一个Class对象。 Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。 获取Class对象1.getClass()方法 12Student s;Class c = s.getClass(); 2.静态方法forName（这个方法在链接数据库时用到过） 12String className = \"java.util.Random\";Class c = Class.forName(className); 3.通过数据类型获得Class对象（包括基本数据类型） 123Class c1 = Random.class;Class c2 = int.class;Class c3 = Double[].class; 利用反射分析类通过反射获取构造方法并使用Class类中提供了几种方法用来获取构造方法 Constructor类提供了调用构造方法的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package reflectDemo;public class Student &#123; public String name; private int age; protected char sex; public Student(String name)&#123; this.name = name; System.out.println(\"name is : \"+name); &#125; protected Student(int age)&#123; this.age = age; System.out.println(\"age is : \"+ age); &#125; private Student(String name,int age)&#123; this.name = name; this.age = age; System.out.println(\"name is : \"+name+\"and age is : \"+age); &#125;&#125;=========================================================== package reflectDemo;import java.lang.reflect.Constructor;public class ConstructorDemo &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName(\"reflectDemo.Student\"); System.out.println(\"**********************所有公有构造方法***************************\"); Constructor[] conArray = c.getConstructors(); for (Constructor n : conArray) &#123; System.out.println(n); &#125; System.out.println(\"************所有的构造方法(包括：私有、受保护、默认、公有)***************\"); conArray = c.getDeclaredConstructors(); for (Constructor n : conArray) &#123; System.out.println(n); &#125; System.out.println(\"*****************获取公有构造方法，并调用**********************\"); Constructor con = c.getConstructor(String.class); System.out.println(con); //调用构造方法 Object obj = con.newInstance(\"张三\"); System.out.println(\"****************获取私有构造方法，并调用***********************\"); con = c.getDeclaredConstructor(String.class,int.class); System.out.println(con); //暴力访问(忽略掉访问修饰符) con.setAccessible(true); //调用构造方法 obj = con.newInstance(\"李四\",18); &#125;&#125;=========================================================== Output: /** **********************所有公有构造方法********************************** public reflectDemo.Student(java.lang.String)* ************所有的构造方法(包括：私有、受保护、默认、公有)**************** public reflectDemo.Student(java.lang.String)* protected reflectDemo.Student(int)* private reflectDemo.Student(java.lang.String,int)* *****************获取公有构造方法，并调用******************************* public reflectDemo.Student(java.lang.String)* name is : 张三* ******************获取私有构造方法，并调用****************************** private reflectDemo.Student(java.lang.String,int)* name is : 李四 and age is : 18*/ 通过反射获取成员变量并调用同样Class类提供了对应的方法 filed类方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package reflectDemo;public class Student &#123; public String name; private int age; protected char sex; public Student()&#123;&#125; public int getAge()&#123; return age; &#125;&#125;================================================================= package reflectDemo;import java.lang.reflect.Field;public class FiledDemo &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class c = Class.forName(\"reflectDemo.Student\"); //2.获取字段 System.out.println(\"************获取所有公有的字段********************\"); Field[] fieldArray = c.getFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(\"************获取所有的字段(包括私有、受保护、默认的)********************\"); fieldArray = c.getDeclaredFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(\"*************获取公有字段并调用******************************\"); Field f = c.getField(\"name\"); System.out.println(f); //获取一个对象 Object obj = c.getConstructor().newInstance();//产生Student对象--》Student stu = new Student(); //为字段设置值 f.set(obj, \"张三\");//为Student对象中的name属性赋值 //验证是否成功 Student stu = (Student)obj; System.out.println(\"name：\" + stu.name); System.out.println(\"**************获取私有字段并调用*****************************\"); f = c.getDeclaredField(\"age\"); System.out.println(f); //暴力反射，解除私有限定 f.setAccessible(true); f.set(obj, 19); System.out.println(\"age：\" + stu.getAge()); &#125;&#125;================================================================== Output:/* *********************获取所有公有的字段******************* public java.lang.String reflectDemo.Student.name *******获取所有的字段(包括私有、受保护、默认的)************* public java.lang.String reflectDemo.Student.name private int reflectDemo.Student.age protected char reflectDemo.Student.sex *************获取公有字段并调用*************************** public java.lang.String reflectDemo.Student.name name：张三 **************获取私有字段并调用************************** private int reflectDemo.Student.age age：19*/ 通过反射获取成员方法并调用class类提供的方法 method类提供的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package reflectDemo;public class Student &#123; public void show1(String name)&#123; System.out.println(\"调用了含参公有方法，参数为：\"+name); &#125; protected void show2()&#123; System.out.println(\"调用了公有方法\"); &#125; private void show3(int age)&#123; System.out.println(\"调用了含参私有方法，参数为：\"+age); &#125;&#125;=========================================================================== package reflectDemo;import java.lang.reflect.Method;public class MethodDemo &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class c = Class.forName(\"reflectDemo.Student\"); //2.获取所有公有方法 System.out.println(\"***************获取所有的”公有“方法*******************\"); Method[] methodArray = c.getMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(\"***************获取所有的方法，包括私有的*******************\"); methodArray = c.getDeclaredMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(\"***************获取公有的show1()方法*******************\"); Method m = c.getMethod(\"show1\", String.class); System.out.println(m); //实例化一个Student对象 Object obj = c.getConstructor().newInstance(); m.invoke(obj, \"张三\"); System.out.println(\"***************获取私有的show4()方法******************\"); m = c.getDeclaredMethod(\"show3\", int.class); System.out.println(m); //解除私有限定 m.setAccessible(true); m.invoke(obj, 19); &#125;&#125;==============================================================================Output:/* ***************获取所有的”公有“方法******************* public void reflectDemo.Student.show1(java.lang.String) public int reflectDemo.Student.getAge() public final void java.lang.Object.wait() throws java.lang.InterruptedException public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public java.lang.String java.lang.Object.toString() public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() ***************获取所有的方法，包括私有的************** private void reflectDemo.Student.show3(int) protected void reflectDemo.Student.show2() public void reflectDemo.Student.show1(java.lang.String) public int reflectDemo.Student.getAge() ***************获取公有的show1()方法******************* public void reflectDemo.Student.show1(java.lang.String) 调用了含参公有方法，参数为：张三 ***************获取私有的show4()方法******************* private void reflectDemo.Student.show3(int) 调用了含参私有方法，参数为：19*/ 可以看到在公有方法中也输出了Object类中继承的一些方法。 同时也能通过如下方法执行main方法 12m = c.getMethod(\"main\", String[].class);m.invoke(null, (Object)new String[]&#123;&#125;);//第二个参数在jdk1.4是数组，在jdk1.5及以后是可变参数，要进行强转 还可以调用method类的其他方法越过泛型检查，传入不同类型的参数。 具体参考：Java基础—反射","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Java基础知识复习整理（二）","slug":"Java基础知识复习整理（二）","date":"2020-02-27T13:58:55.228Z","updated":"2020-03-02T12:17:30.126Z","comments":true,"path":"2020/02/27/Java基础知识复习整理（二）/","link":"","permalink":"http://yoursite.com/2020/02/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"对象与类面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了20世纪70年代的“结构化”过程化程序设计开发技术。Java是完全面向对象的， 必须熟悉OOP才能够编写Java程序。 类类是构造对象的模板。由类构造对象的过程称为创建类的实例。对象中的数据称为实例域，操作数据的过程称为方法。对于特定的实例都有一组特定的实例域值，这些值的集合就是对象的当前状态。无论何时，只要像对象发送一个消息，他的状态就有可能发生改变。 类与类的关系依赖(Dependency)是一种”use-a”关系，大多数情况下依赖关系体现在某个类的方法使用另一个类的对象作为参数。 聚合(Aggregation)是一种“ has-a” 关系，是一种具体且易于理解的关系。例如，一个Order对象包含一些Item对象。聚合关系意味着类 A 的对象包含类 B 的对象。 继承(Inheritance)是一种”is-a”关系，子类从父类中继承了一些方法以及参数。","text":"对象与类面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了20世纪70年代的“结构化”过程化程序设计开发技术。Java是完全面向对象的， 必须熟悉OOP才能够编写Java程序。 类类是构造对象的模板。由类构造对象的过程称为创建类的实例。对象中的数据称为实例域，操作数据的过程称为方法。对于特定的实例都有一组特定的实例域值，这些值的集合就是对象的当前状态。无论何时，只要像对象发送一个消息，他的状态就有可能发生改变。 类与类的关系依赖(Dependency)是一种”use-a”关系，大多数情况下依赖关系体现在某个类的方法使用另一个类的对象作为参数。 聚合(Aggregation)是一种“ has-a” 关系，是一种具体且易于理解的关系。例如，一个Order对象包含一些Item对象。聚合关系意味着类 A 的对象包含类 B 的对象。 继承(Inheritance)是一种”is-a”关系，子类从父类中继承了一些方法以及参数。 final实例域可以将实例域定义为final。构建对象时必须初始化这样的域，并且在后面的操作中不能对它进行修改。 12345class Student&#123; private final String name; . . .&#125; 静态域与静态方法静态域如果将域定义为static，那么这个域将被这个类所有的实例共享，不管有多少个实例存在，静态域只有一个，即使没有实例，它也存在。它属于类，不属于任何独立的对象。 静态方法静态方法不能操作对象，可以有类名直接调用。 方法参数将参数传递给方法有：按值调用，表示方法接受的是调用者提供的值。按引用调用，表示方法接受的是调用者提供的变量地址。Java对基础变量作为参数是按值调用，而对象作为参数传递的是引用拷贝。 参考：关于Java对象作为参数传递是传值还是传引用的问题 调用另外的构造器在一个构造器中，可以通过如下的this语句调用一个类的另外一个构造器。 12345public Student (int age)&#123; //call Student(String name,int age) this(\"xxxx\",age);&#125; 初始化块Java给数据域赋值可以通过构造器和声明，第三种方法就是初始化块。 12345678910class Student&#123; private int age; private String name; //initialization block &#123; age = 0; name = \"\"; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础知识复习整理（一）","slug":"Java基础知识复习整理（一）","date":"2020-02-27T12:30:22.371Z","updated":"2020-03-02T12:42:19.135Z","comments":true,"path":"2020/02/27/Java基础知识复习整理（一）/","link":"","permalink":"http://yoursite.com/2020/02/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Java基础知识复习整理（一）1.Java数据类型在Java中，一共有8种基本数据类型，其中包括4种整型，2种浮点类型和1中用于表示Unicode编码的字符单元的字符类型char和1中用于表示真值的布尔(boolean)类型。 1.1 整型 类型 存储需求 取值范围 byte 1字节 -128~127 short 2字节 -32 768~32 767 int 4字节 -2 147 483 648~2 147 483 647 long 8字节 -9 223 372 036 854 775 808~9 223 372 036 854 775 807 整型用于表示没有小数部分的数值，允许为负数。与C++不同，Java整型的范围与运行Java代码的机器无关，这也是Java可以在各个平台方便移植的原因之一。 从 Java7 开始， 加上前缀 0b 或 0B 就可以写二进制数。例如，0b1001就是 9。","text":"Java基础知识复习整理（一）1.Java数据类型在Java中，一共有8种基本数据类型，其中包括4种整型，2种浮点类型和1中用于表示Unicode编码的字符单元的字符类型char和1中用于表示真值的布尔(boolean)类型。 1.1 整型 类型 存储需求 取值范围 byte 1字节 -128~127 short 2字节 -32 768~32 767 int 4字节 -2 147 483 648~2 147 483 647 long 8字节 -9 223 372 036 854 775 808~9 223 372 036 854 775 807 整型用于表示没有小数部分的数值，允许为负数。与C++不同，Java整型的范围与运行Java代码的机器无关，这也是Java可以在各个平台方便移植的原因之一。 从 Java7 开始， 加上前缀 0b 或 0B 就可以写二进制数。例如，0b1001就是 9。 1.2 浮点类型 类型 存储需求 取值范围 float 4字节 大约 ± 3.402 82347E+38F (有效位数为6~7位） double 8字节 大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位） 浮点类型使用科学技术法表示一个数，可以表示非常大的数，但是牺牲了精度(这取决于有效数字的位数)。通常float类型的精度难以满足要求，一般使用double类型。 浮点溢出有3个特殊的浮点值分别是：正无穷大(Double.POSITIVE_INFINITY)，负无穷大(Double.NEGATIVE_INFINITY)和不是一个数字(NaN)。 浮点数值由于采用二进制系统表示，不适用与无法接受舍入的计算中。例如在Java中输入命令System.out.print(2.0-1.1)将会输出0.8999999999999999，而不是0.9。具体原因可以参考计算机组成原理相关的知识。 1.3 Char类型char类型用于表示单个字符，大小为2字节。有些 Unicode 字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。char类型的字面量值要用单引号括起来。例如：’A’是编码值为 65 所对应的字符常量。它与”A”不同，”A”是包含一个字符A的字符串，char类型的值可以表示为十六进制值，其范围从\\u0000 到\\Uffff。例如：\\u03C0表示希腊字母π(一定要注意注释中的\\u)。 由于Unicode字符集已经超出了65 535个，16位的char无法满足需要。从Java SE 5.0开始使用了码点这一概念。码点(code point)是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，码点采用十六进制书写，并加上前缀 U+, 例如U+0041就是拉丁字母A的码点。Unicode的码点可以分成 17 个代码级别(codeplane)。第一个代码级别称为基本的多语言级别(basic multilingual plane), 码点从 U+0000到U+FFFF, 其中包括经典的Unicode代码；其余的16个级另码点从U+10000到U+10FFFF, 其中包括一些辅助字符(supplementary character)。UTF-16 编码采用不同长度的编码表示所有Unicode码点。在基本的多语言级别中，每个字符用16位表示，通常被称为代码单元(code unit); 而辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落人基本的多语言级别中空闲的2048字节内， 通常被称为替代区域(surrogate area) [U+D800 ~ U+DBFF用于第一个代码单元，U+DC00 ~ U+DFFF用 于第二个代码单元]。这样设计十分巧妙，我们可以从中迅速地知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。例如，⑪是八元数集的一个数学符号，码点为U+1D546, 编码为两个代码单元U+D835和U+DD46 1.4 布尔类型boolean(布尔)类型有两个值：false和true，用来判定逻辑条件。与C++不同，整型值和布尔值之间不能进行相互转换。 2.变量2.1 初始化声明变量之后必须使用赋值语句对变量进行初始化，Java不区分变量的声明与定义。 2.2 常量Java使用final关键字声明常量，常量名通常使用全大写。如果希望常量可以在一个类的多个方法中使用，可以使用static final进行声明。 2.3 数值类型之间的转换Java中经常需要把一个数值类型转换为另外一种类型，有些是合法的，而有些则会丢失一部分信息。 当两个不同数值类型的数进行运算时，Java先要将两个操作数转换为同一种类型然后进行计算，转换时会准守如下规则： ​ •如果两个操作数中有一个是double类型， 另一个操作数就会转换为double类型。 ​ •否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。 ​ •否则， 如果其中一个操作数是long类型， 另一个操作数将会转换为long类型。 ​ •否则， 两个操作数都将被转换为int类型。 在必要的时候可以使用强制类型转换，需要通过(cast)实现这个操作。例如： double x = 0.1; int nx = (int)x; 3.运算符3.1 自增与自减运算符有两种形式，前缀：n++，n– 后缀：++n，–n。两者的区别为：前缀形式会先完成加1，而后缀形式会使用变量原来的值。 3.2 关系和boolean运算符使用==检测相等性，使用！=检测不相等，还有&lt;,&gt;,&gt;=,&lt;=运算符。 Java沿用C++使用&amp;&amp;表示逻辑“与”运算，使用||表示逻辑“或”运算。如果第一个操作数能确定表达式的值，则后面的不用计算。可以使用&amp;和|使计算式计算每个表达式的值. 三元操作符condition ？expression1 ： expression2，如果condition为真，则结果为前者，否则为后者。例如x&lt;y ? x : y会返回x，y中较小者。 3.3 位运算符处理整型时可以对数值的各个位完成操作。在掩码技术和加密算法中可以应用。Java的位运算符有：&amp; (“and”)，| (“or”)，^ (“xor”)，~ (“not”)。 例如，如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则 int fourthBitFromRight = (n &amp; 0b1000) / 0b1000; 会返回1，否则返回0。利用&amp;并结合使用适当的2的幂，可以把其他位掩掉， 而只保留其中的某一位。 另外，还有&gt;&gt;和&lt;&lt;运算符将位模式左移或右移，&gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。 4.字符串字符串从概念上讲就是Unicode字符序列。Java没有内置的字符串类型，而是定义了一个String类，每个双引号括起来的字符串都是String类的一个实例。 4.1 子串与拼接String类的substring方法可以截取字符串的子串，第一个参数是开始的位置，第二个参数是截取的长度。Java允许字符串之间使用+号进行连接。当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。常用的输出语句中的整型变量实则是被转换成了字符串。 4.2 不可变字符串String类不提供修改字符串的方法，改变字符串变量实际上是让它指向了另一个字符串。Java可以将字符串常量的实例放在一个公共的存储池中进行共享，如果复制一个字符串变量，原始字符串变量与复制的变量指向同一个实例。 4.3 检测字符串是否相等可以使用equals方法检测两个字符串是否相等。不要使用==检测两个字符串是否相等，它只能确定两个字符串是否放在同一个位置上，即是否是同一个实例。但是完全可以将多个相同内容的字符串的放在不同的位置上。 如果虚拟机始终将相同的字符串共享， 就可以使用==运算符检测是否相等。但实际上只有字符串常量是共享的，而+或substring等操作产生的结果并不是共享的。 4.4 空字符串与Null串空串指的是””，是一个实例对象，有自己的长度(0)和内容(空)。不过，String变量有个特殊的值叫做Null，表示目前该变量没有指向任何对象，使用==判断变量是否为Null。 4.5 码点与代码单元Java的字符串有char值序列组成。大多数char值使用一个代码单元，而有的使用了一对代码单元。String的length方法返回的是字符串的代码单元的数量，charAt(n)返回位置n的代码单元。而对于字符串”⑪”,调用length方法会返回2，而charAt(1)返回的是其第二个代码单元而不是空格。 4.6 StringBuilder类使用拼接字符串的方式产生字符串时每次都会构建新的String对象，浪费空间。而使用StringBuilder类则可以避免这个问题。StringBuilder类提供多种方法可以修改其中的保存的字符串，修改后最后调用toString方法将其变为String类型。 5.输入输出5.1 读取输入想要通过控制台进行输入，需要狗键一个Scanner对象，并与标准输入流System.in关联。代码为：Scanner in = new Scanner(System.in);可以调用Scanner类的各种方法实现输入，如nextLine方法输入一行，还有nextInt等。 5.2 文件输入与输出要想对文件进行读取就要用File对象构建Scanner对象，如需要读取项目根目录下的myfile.txt的内容就可以定义如下对象：Scanner in = new Scanner(Paths.get(“myflle.txt”), “UTF-8”); 然后便可以使用Scanner类的nextLine等方法对文件进行读取。 如果要写入文件，就需要构建PrintWriter对象：PrintWriter out = new PrintWriter(“myfile.txt”, “UTF-8”)，如果文件不存在，则创建该文件。可以像输入到System.out—样使用print、println以及printf方法。 6.数组数组是一种数据结构，用来存储同一类型的值。可以通过下标访问数组中的每一个值。 数组的声明方式为：int[] a = new int[n]; 其中n可以为常量也可以为变量。 创建一个数字数组时，所有元素都初始化为0。boolean类型数组初始化为false。对象数组初始化为null，表示该数组每有存放任何对象。 6.1 for each循环遍历数组Java 有一种功能很强的循环结构， 可以用来依次处理数组中的每个元素而不必为指定下标值而分心。 这种增强的 for 循环的语句格式为： for (variable : collection) statement 6.2 数组拷贝在Java中，允许将一个数组变量拷贝到另一个数组变量，两个变量将引用同一个数组。 如果希望将一个数组的所有值拷贝到一个新的数组中去，可以使用Array类的copyOf方法，该方法通常用来增加数组的大小 6.3 数组排序Array类的sort方法提供了一个优化的快速排序算法。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-26T11:24:40.674Z","updated":"2020-02-26T11:24:40.674Z","comments":true,"path":"2020/02/26/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}